"""Assignment 2 functions."""

from typing import List


THREE_BY_THREE = [[1, 2, 1],
                  [4, 6, 5],
                  [7, 8, 9]]

FOUR_BY_FOUR = [[1, 2, 6, 5],
                [4, 5, 3, 2],
                [7, 9, 8, 1],
                [1, 2, 1, 4]]

UNIQUE_3X3 = [[1, 2, 3],
              [9, 8, 7],
              [4, 5, 6]]

UNIQUE_4X4 = [[10, 2, 3, 30],
              [9, 8, 7, 11],
              [4, 5, 6, 12],
              [13, 14, 15, 16]]


def compare_elevations_within_row(elevation_map: List[List[int]], map_row: int, 
                                  level: int) -> List[int]:
    """Return a new list containing the three counts: the number of
    elevations from row number map_row of elevation map elevation_map
    that are less than, equal to, and greater than elevation level.

    Precondition: elevation_map is a valid elevation map.
                  0 <= map_row < len(elevation_map).

    >>> compare_elevations_within_row(THREE_BY_THREE, 1, 5)
    [1, 1, 1]
    >>> compare_elevations_within_row(FOUR_BY_FOUR, 1, 2)
    [0, 1, 3]

    """
    
    greater = 0
    lesser = 0
    equal = 0
    
    for nums in elevation_map[map_row]:
        if nums > level:
            greater += 1
        elif nums < level:
            lesser += 1
        else:
            equal += 1
    return [lesser, equal, greater]


def update_elevation(elevation_map: List[List[int]], start: List[int],
                     stop: List[int], delta: int) -> None:
    """Modify elevation map elevation_map so that the elevation of each
    cell between cells start and stop, inclusive, changes by amount
    delta.

    Precondition: elevation_map is a valid elevation map.
                  start and stop are valid cells in elevation_map.
                  start and stop are in the same row or column or both.
                  If start and stop are in the same row,
                      start's column <=  stop's column.
                  If start and stop are in the same column,
                      start's row <=  stop's row.
                  elevation_map[i, j] + delta >= 1
                      for each cell [i, j] that will change.

    >>> THREE_BY_THREE_COPY = [[1, 2, 1],
    ...                        [4, 6, 5],
    ...                        [7, 8, 9]]
    >>> update_elevation(THREE_BY_THREE_COPY, [1, 0], [1, 1], -2)
    >>> THREE_BY_THREE_COPY
    [[1, 2, 1], [2, 4, 5], [7, 8, 9]]
    >>> FOUR_BY_FOUR_COPY = [[1, 2, 6, 5],
    ...                      [4, 5, 3, 2],
    ...                      [7, 9, 8, 1],
    ...                      [1, 2, 1, 4]]
    >>> update_elevation(FOUR_BY_FOUR_COPY, [1, 2], [3, 2], 1)
    >>> FOUR_BY_FOUR_COPY
    [[1, 2, 6, 5], [4, 5, 4, 2], [7, 9, 9, 1], [1, 2, 2, 4]]

    """
    for row in range(start[0], stop[0] + 1):
        for column in range(start[1], stop[1] + 1):
            elevation_map[row][column] = elevation_map[row][column] + delta
    
def get_average_elevation(elevation_map: List[List[int]]) -> float:
    """Return the average elevation across all cells in the elevation map
    elevation_map.

    Precondition: elevation_map is a valid elevation map.

    >>> get_average_elevation(UNIQUE_3X3)
    5.0
    >>> get_average_elevation(FOUR_BY_FOUR)
    3.8125
    """
    sum = 0
    for row in range(len(elevation_map)):
        for column in range(len(elevation_map[row])):
            sum = sum + elevation_map[row][column]
    return sum / (len(elevation_map) * len(elevation_map[0]))


def find_peak(elevation_map: List[List[int]]) -> List[int]:
    """Return the cell that is the highest point in the elevation map
    elevation_map.

    Precondition: elevation_map is a valid elevation map.
                  Every elevation value in elevation_map is unique.

    >>> find_peak(UNIQUE_3X3)
    [1, 0]
    >>> find_peak(UNIQUE_4X4)
    [0, 3]
    """

    highest_point =[]
    highest_num = 0
    for row in range(len(elevation_map)):
        for column in range(len(elevation_map[row])):
            if elevation_map[row][column] > highest_num:
                highest_num = elevation_map[row][column]
                highest_point = [row, column]
                
    return highest_point

def middle_cell(elevation_map: List[List[int]], cell: List[int]) -> bool:
    """Return False if cell is not a sink. Checks cells that are not along the borders 
    of elevation_map.
    
    Precondiiton: elevation_map is a valid elevation map. Cell is a 2-element list.
    The cell is not along the border of elevation_map.
    
    >>>middle_cell(THREE_BY_THREE, [1, 1])
    False
    >>>is_sink(FOUR_BY_FOUR, [2, 2is_sink(FOUR_BY_FOUR, [2, 2])])
    False
    """
    for i in [-1, 0, 1]: 
        for j in [-1, 0, 1]: 
            if elevation_map[cell[0] + i][cell[1] + j] < elevation_map[cell[0]][cell[1]]:
                return False
    
    return True
            
def column_cell(elevation_map: List[List[int]], cell: List[int]) -> bool:
    """Return False if cell is not a sink. Checks cells whose columns are on the 
    borders of elevation_map.
    
    Precondiiton: elevation_map is a valid elevation map. Cell is a 2-element list. 
    The second element of cell is along the border of elevation_map.
    
    >>>column_cell(FOUR_BY_FOUR, [2, 3])
    True
    >>>column_cell(FOUR_BY_FOUR, [1, 3])
    False
    """
    for i in [-1, 0, 1]:
        if elevation_map[cell[0] + i][cell[1]] < elevation_map[cell[0]][cell[1]]:
            return False        
    
    return True

def row_cell(elevation_map: List[List[int]], cell: List[int]) -> bool:
    """Return False if cell is not a sink. Checks cells whose rows are on the borders 
    of elevation_map.
    
    Precondiiton: elevation_map is a valid elevation map. Cell is a 2-element list.
    The first element of cell is along the border of elevation_map.
    
    >>>row_cell(THREE_BY_THREE, [0, 1])
    False
    >>>row_cell(FOUR_BY_FOUR, [3, 2])
    True
    
    """
    for j in [-1, 0, 1]: 
            if elevation_map[cell[0]][cell[1] + j] < elevation_map[cell[0]][cell[1]]:
                return False

    return True
    
def is_sink(elevation_map: List[List[int]], cell: List[int]) -> bool:
    """Return True if and only if cell exists in the elevation map
    elevation_map and cell is a sink.

    Precondition: elevation_map is a valid elevation map.
                  cell is a 2-element list.

    >>> is_sink(THREE_BY_THREE, [0, 5])
    False
    >>> is_sink(THREE_BY_THREE, [0, 2])
    True
    >>> is_sink(THREE_BY_THREE, [1, 1])
    False
    >>> is_sink(FOUR_BY_FOUR, [2, 3])
    True
    >>> is_sink(FOUR_BY_FOUR, [3, 2])
    True
    >>> is_sink(FOUR_BY_FOUR, [1, 3])
    False
    """
    if cell[0] >= len(elevation_map) or cell[1] >= len(elevation_map) \
       or cell[0] < 0 or cell[1] < 0:
        return False
    
    if cell[0] != 0: # not the first row
        if cell[0] != len(elevation_map) - 1: # not the last row
            if cell[1] != 0: # not the first column
                if cell[1] != len(elevation_map) - 1: # not the last column
                    return middle_cell(elevation_map, cell)
                    
            if cell[1] == len(elevation_map) - 1 or cell[1] == 0: # is the last column
                return column_cell

    if cell[0] == len(elevation_map) - 1 or cell[1] == 0: 
        return row_cell

    return True



def middle_local_sink(elevation_map: List[List[int]], cell: List[int]) -> List[int]:
    """Return the index of the smallest element in elevation_map that is adjacent to 
    the cell. 
    
    Precondiiton: elevation_map is a valid elevation map. 
                  elevation_map contains no duplicate elevation values.
                  cell is a valid cell in elevation_map.
                  The cell is not on the border of elevation_map.
                  
    >>>middle_local_sink(UNIQUE_3X3, [1, 1])
    [0, 0]
    >>>middle_local_sink(UNIQUE_4X4, [2, 2])
    [2, 1]
    """
    sink_location = [cell[0], cell[1]]
    sink_value = elevation_map[cell[0]][cell[1]]
    
    for i in [-1, 0, 1]:
        for j in [-1, 0, 1]:
            if elevation_map[cell[0] + i][cell[1] + j] < sink_value:
                sink_value = elevation_map[cell[0] + i][cell[1] + j]
                sink_location = [cell[0] + i, cell[1] + j]
                
    return sink_location

def column_local_sink(elevation_map: List[List[int]], cell: List[int]) -> List[int]:
    """Return the index of the smallest element in elevation_map that is adjacent to 
    the cell. 
    
    Precondiiton: elevation_map is a valid elevation map. 
                  elevation_map contains no duplicate elevation values.
                  cell is a valid cell in elevation_map.
                  The second element of the cell is along the border of elevation_map.
    
    >>>column_local_sink(UNIQUE_3X3, [2, 0])
    [2, 0]
    >>>column_local_sink(UNIQUE_3X3, [1, 2])
    [1, 1]
    """    
    
    sink_location = [cell[0], cell[1]]
    sink_value = elevation_map[cell[0]][cell[1]]
    
    if cell[1] == 0: # first column
        for i in [-1, 0, 1]:
            if cell[0] + i >= 0 and cell[0] + i < len(elevation_map):
                for j in [0, 1]:
                    if elevation_map[cell[0] + i][cell[1] + j] < sink_value:
                        sink_value = elevation_map[cell[0] + i][cell[1] + j]
                        sink_location = [cell[0] + i, cell[1] + j]
    elif cell[1] == len(elevation_map) - 1:
        for i in [-1, 0, 1]:
            if cell[0] + i >= 0 and cell[0] + i < len(elevation_map):
                for j in [-1, 0]:
                    if elevation_map[cell[0] + i][cell[1] + j] < sink_value:
                        sink_value = elevation_map[cell[0] + i][cell[1] + j]
                        sink_location = [cell[0] + i, cell[1] + j]        
    return sink_location

def row_local_sink(elevation_map: List[List[int]], cell: List[int]) -> List[int]:
    """Return the index of the smallest element in elevation_map that is adjacent to 
    the cell. 
    
    Precondiiton: elevation_map is a valid elevation map. 
                  elevation_map contains no duplicate elevation values.
                  cell is a valid cell in elevation_map.
                  the first element of the cell is along the border of elevation_map
    
    >>>row_local_sink(UNIQUE_3X3, [2, 0])
    [2, 0]
    >>>row_local_sink(UNIQUE_4X4, [3, 2])
    [2, 1]
    
    """
    sink_location = [cell[0], cell[1]]
    sink_value = elevation_map[cell[0]][cell[1]]
    
    if cell[0] == 0: # first row
        for j in [-1, 0, 1]:
            if cell[0] + j >= 0 and cell[0] + j < len(elevation_map):
                for i in [0, 1]:
                    if elevation_map[cell[0] + i][cell[1] + j] < sink_value:
                        sink_value = elevation_map[cell[0] + i][cell[1] + j]
                        sink_location = [cell[0] + i, cell[1] + j]
    if cell[0] == len(elevation_map) - 1:
        for j in [-1, 0, 1]:
            if cell[0] + i >= 0 and cell[0] + i < len(elevation_map):
                for i in [-1, 0]:
                    if elevation_map[cell[0] + i][cell[1] + j] < sink_value:
                        sink_value = elevation_map[cell[0] + i][cell[1] + j]
                        sink_location = [cell[0] + i, cell[1] + j]        
    return sink_location

def find_local_sink(elevation_map: List[List[int]],
                    cell: List[int]) -> List[int]:
    """Return the local sink of cell cell in elevation map elevation_map.

    Precondition: elevation_map is a valid elevation map.
                  elevation_map contains no duplicate elevation values.
                  cell is a valid cell in elevation_map.

    >>> find_local_sink(UNIQUE_3X3, [1, 1])
    [0, 0]
    >>> find_local_sink(UNIQUE_3X3, [2, 0])
    [2, 0]
    >>> find_local_sink(UNIQUE_4X4, [1, 3])
    [0, 2]
    >>> find_local_sink(UNIQUE_4X4, [2, 2])
    [2, 1]
    """
    
    if cell[0] != 0 and cell[0] != len(elevation_map) - 1 and  cell[1] != 0 and \
       cell[1] != len(elevation_map) - 1:
        return middle_local_sink(elevation_map, cell)
    elif cell[1] == 0 or cell[1] == len(elevation_map) - 1: #first/last column
        return column_local_sink(elevation_map, cell)
    elif cell[0] == 0 or cell[0] == len(elevation_map) - 1:
        return row_local_sink(elevation_map, cell)
    
    return cell

def can_hike_to(elevation_map: List[List[int]], start: List[int], dest: List[int], supplies: int) -> bool:
    """Return True if and only if a hiker can go from start to dest in
    elevation_map without running out of supplies.

    Precondition: elevation_map is a valid elevation map.
                  start and dest are valid cells in elevation_map.
                  dest is North-West of start.
                  supplies >= 0

    >>> map = [[1, 6, 5, 6],
    ...        [2, 5, 6, 8],
    ...        [7, 2, 8, 1],
    ...        [4, 4, 7, 3]]
    >>> can_hike_to(map, [3, 3], [2, 2], 10)
    True
    >>> can_hike_to(map, [3, 3], [2, 2], 8)
    False
    >>> can_hike_to(map, [3, 3], [3, 0], 7)
    True
    >>> can_hike_to(map, [3, 3], [3, 0], 6)
    False
    >>> can_hike_to(map, [3, 3], [0, 0], 18)
    True
    >>> can_hike_to(map, [3, 3], [0, 0], 17)
    False

    """
    s_left, r, c = supplies, start[0], start[1]
    pos = elevation_map[r][c]
    if r == 0 and c == 0:
        return True
    while s_left > 0 and r >= dest[0] and c >= dest[1]:
        if r != 0  and c != 0: 
            if elevation_map[r][c - 1] < elevation_map[r - 1][c]:
                pos = elevation_map[r][c - 1]
                s_left -= abs(elevation_map[r][c] - pos)
                c -= 1 
            else:
                pos = elevation_map[r - 1][c]
                s_left -= abs(elevation_map[r][c] - pos)
                r -= 1
        if r == 0:
            pos = elevation_map[r][c - 1]
            s_left -= abs(elevation_map[r][c] - pos)
            c -= 1        
    if s_left < 0:
        return False
    else:
        return pos == elevation_map[dest[0]][dest[1]]
    
def setup_map(elevation_map: List[List[int]]) -> List[List[int]]:
    """Return a new elevation_map that has trailing zeroes along each column and
    an extra r of zeroes at the bottom, given that the elevation_map is odd.
    
    Precondition: elevation_map is a valid elevation map.
    
    >>>setup_map([[1], [2])
    [[1, 0], [2, 0], [0, 0]]
    >>>setup_map([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    [[1, 2, 3, 0], [4, 5, 6, 0], [7, 8, 9, 0], [0, 0, 0, 0]]
    """
    if len(elevation_map) % 2 != 0:
        length = len(elevation_map)
        for r in range(length):
            elevation_map[r].append(0)
        elevation_map.append([0] * (length + 1))    
    return elevation_map

def get_lower_resolution(elevation_map: List[List[int]]) -> List[List[int]]:
    """Return a new elevation map, which is constructed from the values
    of elevation_map by decreasing the number of elevation points
    within it.

    Precondition: elevation_map is a valid elevation map.

    >>> get_lower_resolution(
    ...     [[1, 6, 5, 6],
    ...      [2, 5, 6, 8],
    ...      [7, 2, 8, 1],
    ...      [4, 4, 7, 3]])
    [[3, 6], [4, 4]]
    >>> get_lower_resolution(
    ...     [[7, 9, 1],
    ...      [4, 2, 1],
    ...      [3, 2, 3]])
    [[5, 1], [2, 3]]

    """
    n_map, index, add, r, c, l = [], 0, 0, 0, 0, len(elevation_map)
    elevation_map = setup_map(elevation_map)
    for length in range((len(elevation_map) // 2)):
        n_map.append([])    
    while r < len(elevation_map)  - 1:
        while c < len(elevation_map) - 1:
            for i in range(2): 
                add = add + elevation_map[r + i][c] + elevation_map[r + i][c + 1]
            if c + 1 == l and r + 1 == l:
                n_map[index].append(add)
            elif c + 1 == l or r + 1== l:
                n_map[index].append(add // 2)
            else:
                n_map[index].append(add // 4)
            c += 2
            add = 0
        index += 1
        r += 2
        c = 0       
    return n_map
